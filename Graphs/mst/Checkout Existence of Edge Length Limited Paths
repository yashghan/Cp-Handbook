https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/

class DSU{
	vector<int> parent,size;

	public:
	DSU(int n){
		parent.resize(n);
		size.resize(n,1);
		for(int i=0; i<n; i++)
			parent[i]= i;
	}

	int findParent(int x){
		if(x == parent[x])
			return x;
		return parent[x]= findParent(parent[x]);
	}

	void unite(int small, int large){
		small = findParent(small);
		large = findParent(large);
		if(small == large)
			return;
		if(size[small] > size[large])
			swap(small,large);

		size[large] += size[small];
		parent[small]= large;
	}
};

bool cmp(vector<int> &v1, vector<int> &v2){
    return v1[2] < v2[2];
}

class Solution {
public:
    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {
        
        DSU dsu(n);
        sort(edgeList.begin(), edgeList.end(), cmp);
        for(int i = 0; i<queries.size(); i++) queries[i].push_back(i);
        sort(queries.begin(), queries.end(), cmp);
        vector<bool> ans(queries.size(), false);
        int id = 0;
        for(int i = 0; i < queries.size(); i++){
            while(id < edgeList.size() && edgeList[id][2] < queries[i][2]){
                dsu.unite(edgeList[id][0], edgeList[id][1]);
                id++;
            }
            if(dsu.findParent(queries[i][0]) == dsu.findParent(queries[i][1])) ans[queries[i][3]] = true;
        }
                         
        return ans;                       
        
    }
};
