https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/

class DSU{
	vector<int> parent,size;

	public:
	DSU(int n){
		parent.resize(n);
		size.resize(n,1);
		for(int i=0; i<n; i++)
			parent[i]= i;
	}

	int findParent(int x){
		if(x == parent[x])
			return x;
		return parent[x]= findParent(parent[x]);
	}

	void unite(int small, int large){
		small = findParent(small);
		large = findParent(large);
		if(small == large)
			return;
		if(size[small] > size[large])
			swap(small,large);

		size[large] += size[small];
		parent[small]= large;
	}
};

// comparator
bool comp(vector<int> &v1, vector<int> &v2){
	return v1[2]< v2[2];
}


class Solution {
public:

	// spanning tree
	int kruskal(int n, int i, bool exclude, vector<vector<int>> &edges){
		DSU dsu(n);
		int mst= 0;
		int e= 0;
		if(!exclude){
			dsu.unite(edges[i][0],edges[i][1]);
			mst += edges[i][2];
			e=1;
		}

		for(int j=0; j<edges.size(); j++){
			if(e == n-1)
				break;

			if(exclude && j==i) continue;
			if(dsu.findParent(edges[j][0])== dsu.findParent(edges[j][1])) continue;

			dsu.unite(edges[j][0], edges[j][1]);
			mst += edges[j][2];
			e++;

		}        
		if(e != n-1)
			return -1;

		return mst;

	}


	vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {

		unordered_map<string, int> index;
		for(int i=0; i<edges.size(); i++){
			string key = to_string(edges[i][0])+','+to_string(edges[i][1])+','+to_string(edges[i][2]);
			index[key]=i;
		}

		sort(edges.begin(), edges.end(), comp);
		int minMST = kruskal(n,0,false,edges);
		// kruskal(n,index , exclude index ?, sorted edges)

		vector<int> critical, pseudo;
		// exclude an edge and check mst value
		// if(new mst > minMST) critical
		// if(new mst == minMST) 
		// we've to check whether this removed edges is part of some mst ?
		// ie. this edges is part of some MST which gives minMST, and if we remove this edges also
		// we're geting mas == minMST

		for(int i=0; i<edges.size(); i++){
			int newMST = kruskal(n,i,true,edges);

string key = to_string(edges[i][0])+','+to_string(edges[i][1])+','+to_string(edges[i][2]);

			if(newMST > minMST || newMST== -1)
				critical.push_back(index[key]);
			else if(newMST == minMST){
				// add this edges forcefully and check whether it's part of some mst giving minMST
				int forcedMST = kruskal(n,i,false,edges);
				if(forcedMST == minMST)
					pseudo.push_back(index[key]);
			}
		}

		vector<vector<int>> ans;
		ans.push_back(critical);
		ans.push_back(pseudo);

		return ans;

	}
};
