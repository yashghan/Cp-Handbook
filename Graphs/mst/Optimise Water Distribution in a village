There are n houses in a village. We want to supply water for all the houses by building wells and laying pipes.

For each house i, we can either build a well inside it directly with cost wells[i], or pipe in water from another well to it. The costs to lay pipes between houses are given by the array pipes, where each pipes[i] = [house1, house2, cost] represents the cost to connect house1 and house2 together using a pipe. Connections are bidirectional.

Find the minimum total cost to supply water to all houses.

Example 1:

Input: n = 3, wells = [1,2,2], pipes = [[1,2,1],[2,3,1]]
Output: 3
Explanation: 
The image shows the costs of connecting houses using pipes.
The best strategy is to build a well in the first house with cost 1 and connect the other houses to it with cost 2 so the total cost is 3.

Constraints:

1 <= n <= 10000
wells.length == n
0 <= wells[i] <= 10^5
1 <= pipes.length <= 10000
1 <= pipes[i][0], pipes[i][1] <= n
0 <= pipes[i][2] <= 10^5
pipes[i][0] != pipes[i][1]
example 1 pic:


class DSU{
	vector<int> parent,size;

	public:
	DSU(int n){
		parent.resize(n+1);
		size.resize(n+1,1);
		for(int i=0; i<=n; i++)
			parent[i]= i;
	}

	int findParent(int x){
		if(x == parent[x])
			return x;
		return parent[x]= findParent(parent[x]);
	}

	void unite(int small, int large){
		small = findParent(small);
		large = findParent(large);
		if(small == large)
			return;
		if(size[small] > size[large])
			swap(small,large);

		size[large] += size[small];
		parent[small]= large;
	}
};

bool cmp(pair<int, pair<int, int>> &p1, pair<int, pair<int, int>> &p2){
    return p1.first < p2.first;
}

class Solution{
    public:
 int minCostToSupplyWater(int n, vector<int>& wells, vector<vector<int>>& pipes) {
     // priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;
     vector<pair<int, pair<int, int>>> ds;
     
     for(int i = 0; i < wells.size(); i++){
         // pq.emplace({wells[i], {0, i+1}});
         ds.push_back({wells[i], {0, i+1}});
     }
     
     for(int i = 0; i < pipes.size(); i++){
         // pq.emplace({pipes[i][2], {pipes[i][0], pipes[i][1]}});
         ds.push_back({pipes[i][2], {pipes[i][0], pipes[i][1]}});
     }
     sort(ds.begin(), ds.end(), cmp);
     
     DSU dsu(n);
     int minCost = 0;
     int edges = n;
     for(int i = 0; i < n; i++){
         
         if(edges > 0){
            int pa = dsu.findParent(ds[i].second.first);
            int pb = dsu.findParent(ds[i].second.second);
            // auto it = pq.top();
            // pq.pop();
            // int pa = dsu.findParent(it.second.first);
            // int pb = dsu.findParent(ds[i].second.second);
         
            if(pa != pb){
                dsu.unite(pa, pb);
                edges--;
                minCost += ds[i].first;
                // minCost += it.first;
            }
         }
     }
     return minCost;
  }
};
