class DSU{
	vector<int> parent,size;

	public:
	DSU(int n){
		parent.resize(n+1);
		size.resize(n+1,1);
		for(int i=0; i<=n; i++)
			parent[i]= i;
	}

	int findParent(int x){
		if(x == parent[x])
			return x;
		return parent[x]= findParent(parent[x]);
	}

	void unite(int small, int large){
		small = findParent(small);
		large = findParent(large);
		if(small == large)
			return;
		if(size[small] > size[large])
			swap(small,large);

		size[large] += size[small];
		parent[small]= large;
	}
};

bool cmp(pair<int, pair<int, int>> &p1, pair<int, pair<int, int>> &p2){
    return p1.first < p2.first;
}

class Solution{
    public:
 int minCostToSupplyWater(int n, vector<int>& wells, vector<vector<int>>& pipes) {
     // priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;
     vector<pair<int, pair<int, int>>> ds;
     
     for(int i = 0; i < wells.size(); i++){
         // pq.emplace({wells[i], {0, i+1}});
         ds.push_back({wells[i], {0, i+1}});
     }
     
     for(int i = 0; i < pipes.size(); i++){
         // pq.emplace({pipes[i][2], {pipes[i][0], pipes[i][1]}});
         ds.push_back({pipes[i][2], {pipes[i][0], pipes[i][1]}});
     }
     sort(ds.begin(), ds.end(), cmp);
     
     DSU dsu(n);
     int minCost = 0;
     int edges = n;
     for(int i = 0; i < n; i++){
         
         if(edges > 0){
            int pa = dsu.findParent(ds[i].second.first);
            int pb = dsu.findParent(ds[i].second.second);
            // auto it = pq.top();
            // pq.pop();
            // int pa = dsu.findParent(it.second.first);
            // int pb = dsu.findParent(ds[i].second.second);
         
            if(pa != pb){
                dsu.unite(pa, pb);
                edges--;
                minCost += ds[i].first;
                // minCost += it.first;
            }
         }
     }
     return minCost;
  }
};
