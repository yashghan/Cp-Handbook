https://leetcode.com/problems/number-of-restricted-paths-from-first-to-last-node/

class Solution {
public:
    
    int mod;
    vector<int> dp; // Memoization Table
    
    // Function to DFS over all nodes according to condition given in problem.
    int dfs(vector<vector<pair<int, int>>>& g, vector<long long>& dist, int node){
        if(dp[node]!=-1)
            return dp[node];
        int ans=0;
        for(auto it: g[node])
            if(dist[it.first] < dist[node])
                ans = (ans+dfs(g, dist, it.first))%mod;
        return dp[node] = ans;
        
    }
    
    int countRestrictedPaths(int n, vector<vector<int>>& edges) {
        vector<vector<pair<int, int>>> g(n);
        for(auto v: edges){
            g[v[0]-1].push_back({v[1]-1, v[2]});
            g[v[1]-1].push_back({v[0]-1, v[2]});
        }
        
        vector<long long> dist(n, INT_MAX);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        dist[n-1] = 0;
        pq.push({dist[n-1], n-1});
        
        while(!pq.empty()){
            int prev_node = pq.top().second;
            int prev_dist = pq.top().first;
            pq.pop();
            
            for(auto it: g[prev_node]){
                int cur_node = it.first;
                int cur_dist = it.second;
                
                if(dist[prev_node] != INT_MAX && dist[cur_node] > dist[prev_node] + cur_dist){
                    dist[cur_node] = dist[prev_node] + cur_dist;
                    pq.push({dist[cur_node], cur_node});
                }
            }
        }
        
        //dist -> all minimum distances of respective nodes from node 5
        
        //Initialize Memoization Table
        dp.resize(n, -1);
        dp[n-1] = 1;
        mod = 1e9+7;
		// Call DFS Function to find final answer
        return dfs(g, dist, 0);
        
    }
};
