https://leetcode.com/problems/second-minimum-time-to-reach-destination/

class Solution {
public:
    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {
        vector<vector<int>> g(n+1);
        for(auto v: edges){
            g[v[0]].push_back(v[1]);
            g[v[1]].push_back(v[0]);
        }
        
        vector<int> freq(n+1, 0);
        vector<int> weight(n+1, INT_MAX);
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        
        pq.push({0, 1});
        weight[1] = 0;
        int cnt = 0;
        
        while(!pq.empty()){
            int u = pq.top().second;
            int w = pq.top().first;
            pq.pop();
            freq[u] += 1;
            
            int elapse = w / change;
            if(elapse%2) 
                w += (change * (elapse+1)) - w;
            
            for(int v : g[u]){
                if(w + time != weight[v] && freq[v] <= 2) {
                    weight[v] = w + time;
                    if(v == n) {
                        cnt += 1;
                        if(cnt == 2)
                            return weight[v];
                    }  
                    pq.push({weight[v], v});
                }  
            }
        }
        return 0;
    }
};
