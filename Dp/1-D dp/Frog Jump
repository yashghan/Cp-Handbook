
https://www.codingninjas.com/codestudio/problems/frog-jump_3621012?leftPanelTab=0


Top Down: (Memoization)

#include <bits/stdc++.h>

int f(int ind, vector<int> &heights, vector<int> &dp){
    
    if(ind == 0) return 0;
    if(dp[ind] != -1) return dp[ind];
    int case1 = f(ind-1, heights, dp) + abs(heights[ind] - heights[ind-1]);
    
    int case2 = INT_MAX;
    if(ind > 1){
        case2 = f(ind-2, heights, dp) + abs(heights[ind] - heights[ind-2]);
    }
        
    return dp[ind] = min(case1, case2);
    
}


int frogJump(int n, vector<int> &heights)
{
    vector<int> dp(n, -1);
    return f(n-1, heights, dp);
}



Bottom up: Tabulation


#include <bits/stdc++.h>

int frogJump(int n, vector<int> &heights)
{
    vector<int> dp(n, 0);
    dp[0] = 0;
    for(int i = 1; i < n; i++){
        int case1 = dp[i-1] + abs(heights[i] - heights[i-1]);
        int case2 = INT_MAX;
        if(i > 1){
            case2 = dp[i-2] + abs(heights[i] - heights[i-2]);
        }
        dp[i] = min(case1, case2);
    }
    
    return dp[n-1];
}





Space Optimisation:

#include <bits/stdc++.h>

int frogJump(int n, vector<int> &heights)
{
//     vector<int> dp(n, 0);
//     dp[0] = 0;
    int previ = 0;
    int prev2i = 0;
    
    
    for(int i = 1; i < n; i++){
        int case1 = previ + abs(heights[i] - heights[i-1]);
        int case2 = INT_MAX;
        if(i > 1){
            case2 = prev2i + abs(heights[i] - heights[i-2]);
        }
        int curri = min(case1, case2);
        prev2i = previ;
        previ = curri;
        
    }
    
    return previ;
}
 ====================================================================================================================================

// Modified Question:

// If the frog can make k jumps instead of 1 and 2

TC: O(n*k)
SC: O(n) + O(n)

int f(int ind, vector<int> &heights, vector<int> &dp){
    
  if(ind == 0) return 0;
  
  if(dp[ind] != -1) return dp[ind];
  int ans = INT_MAX;

  for(int i = 1; i <=k; i++){
    if(ind >= i){
      ans = min(ans, f(ind-i, heights, dp) + abs(heights[ind] - heights[ind-i]));
    }
  }    
  return dp[ind] = ans;  
}


TC: O(n * k)
SC: O(n)

int frogJump(int n, vector<int> &heights)
{
    vector<int> dp(n, INT_MAX);
    dp[0] = 0;
    for(int i = 1; i < n; i++){
      for(int j = 1; j <= k; j++){
        if(i >= j){
          ans = min(ans, dp[i-j] + abs(heights[i] - heights[i-j]));
        }
      }
      dp[i] = ans;
    }
    return dp[n-1];
}


