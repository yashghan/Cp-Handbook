https://www.codingninjas.com/codestudio/problems/maze-obstacles_977241?source=youtube&campaign=striver_dp_videos&utm_source=youtube&utm_medium=affiliate&utm_campaign=striver_dp_videos&leftPanelTab=0

Memoization:

TC: O(n * m) + O(n + m - 2) 
SC: O(n * m)

int MOD = (int)(1e9 + 7);
int f(int i, int j, vector< vector< int> > &mat, vector<vector<int>> &dp){
    if(i == 0 && j == 0) return 1;
    if(i < 0 || j < 0) return 0;
    if(i >= 0 && j >= 0 && mat[i][j] == -1) return 0;
    if(dp[i][j] != -1) return dp[i][j];
    
    int left = f(i, j-1, mat, dp);
    int up = f(i-1, j, mat, dp);
    return dp[i][j] = (left + up) % MOD;
}

int mazeObstacles(int n, int m, vector< vector< int> > &mat) {
    vector<vector<int>> dp(n, vector<int> (m, -1));
    return f(n-1, m-1, mat, dp);
}

Tabulation:
TC: O(n * m)
SC: O(n * m)

int mazeObstacles(int n, int m, vector< vector< int> > &mat) {
    int dp[n][m];
    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            if(i == 0 && j == 0) dp[i][j] = 1;
            else if(mat[i][j] == -1) dp[i][j] = 0;
            else{
                int left= 0, up = 0;
                if(j > 0){
                    left = dp[i][j-1];
                }
                if(i > 0){
                    up = dp[i-1][j];
                }
                dp[i][j] = (left + up) % MOD;
            }
        }
    }
    return dp[n-1][m-1];
}

Space Optimisation:

TC: O(n * m)
SC: O(m)

int mazeObstacles(int n, int m, vector< vector< int> > &mat) {
    vector<int> prev(m, 0);
    for(int i = 0; i < n; i++){
        vector<int> curr(m, 0);
        for(int j = 0; j < m; j++){
            
            if(i == 0 && j == 0) curr[j] = 1;
            else if(mat[i][j] == -1) curr[j] = 0;
            else{
                int left= 0, up = 0;
                if(j > 0){
                    left = curr[j-1];
                }
                if(i > 0){
                    up = prev[j];
                }
                curr[j] = (left + up) % MOD;
            }
        }
        prev = curr; 
    }
    return prev[m-1];
}

